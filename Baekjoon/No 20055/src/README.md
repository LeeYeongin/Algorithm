# 📘 BOJ 20055 - 컨베이어 벨트 위의 로봇

## 📄 문제 설명
- 길이가 **2N**인 컨베이어 벨트가 있음.
- 위쪽(1 ~ N)은 로봇이 올라올 수 있는 구간, 아래쪽(N+1 ~ 2N)은 내려가는 구간.
- 각 칸은 내구도(`durability`)를 가짐.
- 로봇은 올리는 위치에서만 올라올 수 있고, 내리는 위치에 도달하면 즉시 내려감.

벨트는 한 단계씩 아래 규칙에 따라 진행됨:
1. **벨트 회전**: 벨트가 한 칸 회전하며 로봇도 같이 이동.
2. **로봇 이동**: 가장 먼저 올라간 로봇부터 순서대로, 다음 칸에 로봇이 없고 내구도가 1 이상이면 한 칸 이동(내구도 -1).
3. **로봇 올리기**: 올리는 위치의 내구도가 0 이상이면 로봇을 올림(내구도 -1).
4. **종료 조건 확인**: 내구도가 0인 칸의 개수가 K 이상이면 종료.

---

## 📥 입력
- 첫째 줄: `N`(벨트 길이 절반), `K`(종료 기준 내구도 0 칸 수)
- 둘째 줄: 벨트 각 칸의 내구도 (길이 `2N`)

---

## 📤 출력
- 몇 번째 단계에서 종료되는지 출력

---

## 📌 제한
- 2 ≤ N ≤ 100
- 1 ≤ K ≤ 2N
- 1 ≤ 각 칸의 내구도 ≤ 100

---

## 💡 해결 아이디어
- **시뮬레이션 문제**
- 벨트와 로봇의 상태를 매 단계마다 그대로 구현해야 함.
- 주의할 점:
    - 내리는 위치에 도달한 로봇은 항상 즉시 내림.
    - 로봇 이동 시 **먼저 올라온 로봇부터** 이동해야 충돌이 없음.
- 종료 조건은 내구도가 0인 칸의 개수를 카운트하며 관리.

---

## 📝 알고리즘 개요
1. 단계(step) 카운트 시작.
2. 벨트 회전 → 로봇 이동 → 새 로봇 올리기.
3. 내구도 0 칸 개수 확인.
4. K 이상이면 종료.
5. 종료될 때까지 반복.
